## 公众号：“弟哥带你进大厂”，让你知识成体系的公众号，一定要关注，我们一起进大厂

## 第9章：Apache-DBUtils实现CRUD操作



### 9.1 Apache-DBUtils简介



-   commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 
-   API介绍： 

<!---->

-   -   org.apache.commons.dbutils.QueryRunner
    -   org.apache.commons.dbutils.ResultSetHandler

<!---->

-   -   工具类：org.apache.commons.dbutils.DbUtils

<!---->

-   API包说明： 



![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb2dd0461420430daf1d3de0ea6d3205~tplv-k3u1fbpfcp-zoom-1.image)


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e503e50e5e847c6b2a4bae55d1fb9dc~tplv-k3u1fbpfcp-zoom-1.image)



### 9.2 主要API的使用



#### 9.2.1 DbUtils


-   DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： 

<!---->

-   -   **public static void close(…) throws java.sql.SQLException**：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。
    -   public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。

<!---->

-   -   public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接
    -   public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。

<!---->

-   -   public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断
    -   public static void rollbackAndClose(Connection conn)throws SQLException

<!---->

-   -   rollbackAndCloseQuietly(Connection)
    -   public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。
    
    #### 9.2.2 QueryRunner类



-    **该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。**
-   QueryRunner类提供了两个构造器： 

<!---->

-   -   默认的构造器
    -   需要一个 javax.sql.DataSource 来作参数的构造器

<!---->

-   QueryRunner类的主要方法： 

<!---->

-   -   **更新**

<!---->

-   -   -   public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。
        -   ......

<!---->

-   -   **插入**

<!---->

-   -   -   public  T insert(Connection conn,String sql,ResultSetHandler rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值
        -   ....

<!---->

-   -   **批处理**

<!---->

-   -   -   public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句
        -   public  T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句

<!---->

-   -   -   .....

<!---->

-   -   **查询**

<!---->

-   -   -   public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。
        -   ......

<!---->

-   测试 


```
// 测试添加
@Test
public void testInsert() throws Exception {
	QueryRunner runner = new QueryRunner();
	Connection conn = JDBCUtils.getConnection3();
	String sql = "insert into customers(name,email,birth)values(?,?,?)";
	int count = runner.update(conn, sql, "何成飞", "he@qq.com", "1992-09-08");

	System.out.println("添加了" + count + "条记录");
		
	JDBCUtils.closeResource(conn, null);

}
```


```
// 测试删除
@Test
public void testDelete() throws Exception {
	QueryRunner runner = new QueryRunner();
	Connection conn = JDBCUtils.getConnection3();
	String sql = "delete from customers where id < ?";
	int count = runner.update(conn, sql,3);

	System.out.println("删除了" + count + "条记录");
		
	JDBCUtils.closeResource(conn, null);

}
```


#### 9.2.3 ResultSetHandler接口及实现类



-   该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 
-   ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 

<!---->

-   接口的主要实现类： 

<!---->

-   -   ArrayHandler：把结果集中的第一行数据转成对象数组。
    -   ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。

<!---->

-   -   **BeanHandler：** 将结果集中的第一行数据封装到一个对应的JavaBean实例中。
    -   **BeanListHandler：** 将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。

<!---->

-   -   ColumnListHandler：将结果集中某一列的数据存放到List中。
    -   KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。

<!---->

-   -   **MapHandler：** 将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。
    -   **MapListHandler：** 将结果集中的每一行数据都封装到一个Map里，然后再存放到List

<!---->

-   -   **ScalarHandler：** 查询单个值对象

<!---->

-   测试 


```
/*
 * 测试查询:查询一条记录
 * 
 * 使用ResultSetHandler的实现类：BeanHandler
 */
@Test
public void testQueryInstance() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	String sql = "select id,name,email,birth from customers where id = ?";
		
	//
	BeanHandler<Customer> handler = new BeanHandler<>(Customer.class);
	Customer customer = runner.query(conn, sql, handler, 23);
	System.out.println(customer);	
	JDBCUtils.closeResource(conn, null);
}
```


```
/*
 * 测试查询:查询多条记录构成的集合
 * 
 * 使用ResultSetHandler的实现类：BeanListHandler
 */
@Test
public void testQueryList() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	String sql = "select id,name,email,birth from customers where id < ?";
		
	//
	BeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);
	List<Customer> list = runner.query(conn, sql, handler, 23);
	list.forEach(System.out::println);
		
	JDBCUtils.closeResource(conn, null);
}
```
```

/*
 * 自定义ResultSetHandler的实现类
 */
@Test
public void testQueryInstance1() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	String sql = "select id,name,email,birth from customers where id = ?";
		
	ResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {

		@Override
		public Customer handle(ResultSet rs) throws SQLException {
			System.out.println("handle");
//			return new Customer(1,"Tom","tom@126.com",new Date(123323432L));
				
			if(rs.next()){
				int id = rs.getInt("id");
				String name = rs.getString("name");
				String email = rs.getString("email");
				Date birth = rs.getDate("birth");
					
				return new Customer(id, name, email, birth);
			}
			return null;
				
		}
	};
		
	Customer customer = runner.query(conn, sql, handler, 23);
		
	System.out.println(customer);
		
	JDBCUtils.closeResource(conn, null);
}
```



```
/*
 * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，
 * 使用ScalarHandler
 * 
 */
@Test
public void testQueryValue() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	//测试一：
//	String sql = "select count(*) from customers where id < ?";
//	ScalarHandler handler = new ScalarHandler();
//	long count = (long) runner.query(conn, sql, handler, 20);
//	System.out.println(count);
		
	//测试二：
	String sql = "select max(birth) from customers";
	ScalarHandler handler = new ScalarHandler();
	Date birth = (Date) runner.query(conn, sql, handler);
	System.out.println(birth);
		
	JDBCUtils.closeResource(conn, null);
}
```

若有收获，就点个赞吧

